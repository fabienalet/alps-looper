/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: node.h 440 2003-10-17 06:33:05Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#ifndef LOOPER_NODE_H
#define LOOPER_NODE_H

#include <alps/osiris.h>
#include <boost/integer_traits.hpp>
#include <boost/static_assert.hpp>
#include <bitset>

namespace looper {

namespace detail {

struct bits
{
  // number of bits
  BOOST_STATIC_CONSTANT(unsigned int, N = 7);
  
  BOOST_STATIC_CONSTANT(unsigned int, CONF = 0); // bit denoting spin direction

  BOOST_STATIC_CONSTANT(unsigned int, REFL = 1);
  BOOST_STATIC_CONSTANT(unsigned int, FREZ = 2); // only for easy-axis cases
  BOOST_STATIC_CONSTANT(unsigned int, ANTI = 3); // only for XYZ cases

  // for path integral
  BOOST_STATIC_CONSTANT(unsigned int, ADDD = 4); // set for newly-added node
  
  // for SSE
  BOOST_STATIC_CONSTANT(unsigned int, IDNT = 5); // identity operator
  BOOST_STATIC_CONSTANT(unsigned int, DIAG = 6); // diagonal operator
  
  // bit mask for clear()
  BOOST_STATIC_CONSTANT(unsigned int,
			M_CLEAR = (1 << CONF) | (1 << IDNT) | (1 << DIAG));
};

} // end namespace detail

class node_type
{
public:
  typedef detail::bits bits;
  typedef std::bitset<bits::N> bitset;
  typedef bitset::reference reference;

  node_type() : type_(0) {}
  void reset() { type_.reset(); }
  void clear_graph() { type_ &= bitset(bits::M_CLEAR); }

  reference conf() { return type_[bits::CONF]; }
  bool conf() const { return type_[bits::CONF]; }
  void flip_conf() { type_.flip(bits::CONF); }
  
  bool is_refl() const { return type_.test(bits::REFL); }
  bool is_frozen() const { return type_.test(bits::FREZ); }
  bool is_anti() const { return type_.test(bits::ANTI); }

  
  // void set_conf(unsigned int c) { type_.set(bits::CONF, c); }

  // for path integral
  bool is_new() const { return type_.test(bits::ADDD); }
  bool is_old() const { return !is_new(); }
  void set_new(unsigned int is_refl, unsigned int is_frozen)
  {
    type_.reset().set(bits::REFL, is_refl).set(bits::FREZ, is_frozen)
      .set(bits::ADDD);
  }
  void set_new(unsigned int is_refl, unsigned int is_frozen,
	       unsigned int is_anti)
  {
    set_new(is_refl, is_frozen);
    type_.set(bits::ANTI, is_anti);
  }
  void set_old(unsigned int is_refl) { type_.set(bits::REFL, is_refl); }
  void set_old(unsigned int is_refl, unsigned int is_frozen)
  { set_old(is_refl); type_.set(bits::FREZ, is_frozen); }
  
  // for SSE
  bool is_identity() const { return type_[bits::IDNT]; }
  bool is_diagonal() const { return type_[bits::DIAG]; }
  bool is_offdiagonal() const { return !is_identity() && !is_diagonal(); }
  void identity_to_diagonal() {
#ifndef NDEBUG
    assert(is_identity());
#endif
    type_.reset(bits::IDNT).set(bits::DIAG);
  }
  void diagonal_to_identity() {
#ifndef NDEBUG
    assert(is_diagonal());
#endif
    type_.reset(bits::DIAG).set(bits::IDNT);
  }
  void diagonal_to_offdiagonal() {
#ifndef NDEBUG
    assert(is_diagonal());
#endif
    type_.reset(bits::DIAG);
  }
  void offdiagonal_to_diagonal() {
#ifndef NDEBUG
    assert(is_offdiagonal());
#endif
    type_.set(bits::DIAG);
  }
  void flip_operator() {
#ifndef NDEBUG
    assert(!is_identity());
#endif
    type_.flip(bits::DIAG);
  }

  void save(alps::ODump& od) const
  { uint32_t b = type_.to_ulong(); od << b; }
  void load(alps::IDump& id)
  { uint32_t b; id >> b; type_ = bitset(b); }
  
private:
  bitset type_;
};

} // end namespace looper

#endif // LOOPER_NODE_H
