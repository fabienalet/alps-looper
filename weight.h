// Looper : Loop Algorithm Library for Quantum Spin Models
//
// Copyright (C) 1997-2003  Synge Todo <wistaria@comp-phys.org>
//
// Permission is hereby granted, free of charge, to any person or
// organization obtaining a copy of the software covered by this
// license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works
// of the Software, and to permit others to do so for non-commerical
// academic use, all subject to the following:
//
// In any scientific publication based in part or wholly on the
// Software, the use of the Software has to be acknowledged.
//
// The copyright notice in the Software and this entire statement,
// including the above license grant, this restriction and the
// following disclaimer, must be included in all copies of the
// Software, in whole or in part, and all derivative works of the
// Software, unless such copies or derivative works are solely in the
// form of machine-executable object code generated by a source
// language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
// NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
// DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
// LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef LOOPER_GRAPHWEIGHT_H
#define LOOPER_GRAPHWEIGHT_H

#include <cmath>

namespace looper {

class GraphWeight
{
public:
  GraphWeight(double jxy, double jz)
  {
    assert(jxy >= 0);
    density_ = std::max(std::abs(jz) / 2, (jxy + std::abs(jz)) / 4);
    if (std::abs(jz) > jxy) {
      freeze_ = 1 - jxy / std::abs(jz);
    } else {
      freeze_ = 0;
    }
    accept_p_ = std::max((jxy + jz) / (jxy + std::abs(jz)), double(0));
    accept_a_ = std::max((jxy - jz) / (jxy + std::abs(jz)), double(0));
  }

  double density() const { return density_; }
  double freeze() const { return freeze_; }
  double accept_p() const { return accept_p_; }
  double accept_a() const { return accept_a_; }
  double accept(int c0, int c1) const {
    return (c0 ^ c1) ? accept_a_ : accept_p_;
  }

  static double reflect(double jxy, double jz)
  {
    return (jxy - jz) / (2 * jxy);
  }

private:
  double density_;
  double freeze_;
  double accept_p_;
  double accept_a_;
};

} // end namespace looper

#endif // LOOPER_LABELER_H
