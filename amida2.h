/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: amida2.h 422 2003-10-15 10:50:28Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#ifndef LOOPER_AMIDA_H
#define LOOPER_AMIDA_H

#include <alps/osiris.h>
#include <boost/throw_exception.hpp>
#include <boost/type_traits.hpp> // for boost::is_class
#include <cmath>
#include <deque>
#include <iosfwd>
#include <iterator>
#include <limits>
#include <stdexcept>

//
// forward declarations
//

namespace looper {

struct amida_node_base
{
  // Convention
  //               link  cut bottom top   vacant
  //  series[0] :   s1    s1   s1    s1    max
  //  series[1] :   s2    s1   max   max   0
  //  next[0]   :   X1    X1   X1    0     X1       goal flag
  //  prev[0]   :   X2    X2   0     X1    X1       root flag
  //  next[1]   :   X3    X1   0     0     0        normal flag
  //  prev[1]   :   X4    0    0     0     0        link flag

  bool at_bottom() const { return prev[0] == 0; }
  bool at_top() const { return next[0] == 0; }
  bool at_boundary() const { return series[1] == _node_max; }
  bool is_link() const { return prev[1] != 0; }
  bool is_cut() const { return series[0] == series[1]; }
  bool is_node() const { return series[0] != _node_max; }
  bool is_vacant() const { return series[0] == _node_max; }

  void set_as_vacant(amida_node_base* t) {
    series[0] = _node_max;
    series[1] = 0;
    next[0] = t;
    prev[0] = t;
    next[1] = 0;
    prev[1] = 0;
  }

  void set_as_bottom(amida_node_base* t, std::size_t s) {
    series[0] = s;
    series[1] = _node_max;
    next[0] = t;
    prev[0] = 0;
    next[1] = 0;
    prev[1] = 0;
  }
    
  void set_as_top(amida_node_base* b, std::size_t s) {
    series[0] = s;
    series[1] = _node_max;
    next[0] = 0;
    prev[0] = b;
    next[1] = 0;
    prev[1] = 0;
  }
    
  std::size_t series[2];
  amida_node_base* next[2];
  amida_node_base* prev[2];

private:
  static const std::size_t _node_max = ~0; // = 111...111
};


template<class T>
struct amida_node : public amida_node_base
{
  T data_;
};


struct amida_series_iterator_base
{
  typedef std::size_t                     size_type;
  typedef std::ptrdiff_t                  difference_type;
  typedef std::bidirectional_iterator_tag iterator_category;
  
  amida_node_base* node_;
  size_type ser_;
  size_type leg_;

  amida_series_iterator_base() : node_(), ser_(), leg_() {}
  amida_series_iterator_base(amida_node_base* x, size_type s)
    : node_(x), ser_(s), leg_()
  {
    if (node_)
      if (node_->series[0] == ser_)
	leg_ = 0;
      else
	leg_ = 1;
  }
  ~amida_series_iterator_base() {}

  size_type series() const { return ser_; }
  size_type leg() const { return leg_; }

  void incr()
  {
    node_ = node_->next[leg_];
    if (node_->series[0] == ser_)
      leg_ = 0;
    else
      leg_ = 1;
  }

  void decr()
  {
    node_ = node_->prev[leg_];
    if (node_->series[0] == ser_)
      leg_ = 0;
    else
      leg_ = 1;
  }

  bool operator==(const amida_series_iterator_base& x) const
  { return node_ == x.node_ && ser_ == x.ser_; }

  bool operator!=(const amida_series_iterator_base& x) const
  { return node_ != x.node_ || ser_ != x.ser_; }
};


template<class T, class Ref, class Ptr>
struct amida_series_iterator : public amida_series_iterator_base
{
  typedef amida_series_iterator<T, T&, T*>             series_iterator;
  typedef amida_series_iterator<T, const T&, const T*> const_series_iterator;
  typedef amida_series_iterator<T, Ref, Ptr>           self_;

  typedef std::size_t   size_type;
  typedef T             value_type;
  typedef Ref           reference;
  typedef Ptr           pointer;
  typedef amida_node<T> node_type;

  amida_series_iterator() {}
  amida_series_iterator(node_type* x, size_type s)
    : amida_series_iterator_base(x, s) {}
  amida_series_iterator(const series_iterator& x)
    : amida_series_iterator_base(x.node_, x.ser_) {}

  reference operator*() const { return ((node_type*)node_)->data_; }
  pointer operator->() const { return &(operator*()); }

  self_ operator++() { this->incr(); return *this; }
  self_ operator++(int) { self_ tmp = *this; this->incr(); return tmp; }
  self_ operator--() { this->decr(); return *this; }
  self_ operator--(int) { self_ tmp = *this; this->decr(); return tmp; }
};


struct amida_series_base
{
  typedef std::size_t size_type;
  
  amida_node_base* bottom_;
  amida_node_base* top_;
  size_type ser_;

  amida_series_base() : bottom_(), top_(), ser_() {}
  amida_series_base(amida_node_base* b, amida_node_base* t, size_type s)
    : bottom_(b), top_(t), ser_(s) {}
  ~amida_series_base() {}
};


// template<class T>
// struct amida_series
// {
//   typedef std::size_t                           size_type;
//   typedef T                                     value_type;
//   typedef amida_series_iterator<T, T&, T*>             iterator;
//   typedef amida_series_iterator<T, const T&, const T*> const_iterator;
//   typedef amida_node<T>                         node_type;

//   amida_series() : amida_series_base() {}
//   amida_series(node_type* b, node_type* t, size_type s)
//     : amida_series_base(b, t, s) {}
//   amida_series(const amida_series& x) : amida_series_base(x.b, x.t, x.s) {}
//   ~amida_series() {}

//   iterator begin() const { return iterator(bottom_, ser_); }
//   const_iterator begin() const { return const_iterator(bottom_, ser_); }
//   iterator end() const { return iterator(top_, ser_); }
//   const_iterator end() const { return const_iterator(top_, ser_); }
// }


template<class T>
class amida
{
public:
  typedef std::size_t                    size_type;
  typedef T                              value_type;
  typedef T&                             reference;
  typedef const T&                       const_reference;
  typedef T*                             pointer;
  typedef const T*                       const_pointer;
  // typedef amida_series<T>                series;
  typedef amida_series_iterator<T, T&, T*> iterator;
  typedef amida_series_iterator<T, const T&, const T*> const_iterator;
  typedef amida_node<T>   node_type;

  // constructors
  explicit amida(size_type r = 0)
    : array_(), vacant_(), num_series_(), num_nodes_(), num_links_(),
    num_cuts_(), largest_(0) { init(r); }
  amida(const amida& a); // not implemented!
  ~amida() {}

  void init(size_type r)
  {
    num_series_ = r;
    array_.resize(2 * num_series_);
    for (size_type i = 0; i < num_series_; ++i) {
      array[i              ].set_as_bottom(&array_[i + num_series_], i);
      array[i + num_series_].set_as_top   (&array_[i              ], i);
    }
    
    // setup stack of vacant nodes
    largest_ = array_.size();
    vacant_ = 0;
    
    // set current number of nodes, etc.
    num_nodes_ = 2 * num_series_;
    num_links_ = 0;
    num_cuts_ = 0;
  }

  void clear() { init(series()); }

  size_type num_series() const { return num_series_; }
  size_type num_nodes() const { return num_nodes_; }
  size_type num_links() const { return num_links_; }
  size_type num_cuts() const { return num_cuts_; }
  size_type num_max_nodes() const { return largest_; }
  size_type capacity() const { return array_.capacity(); }
  double memory() const { return sizeof(node_type) * capacity(); }

  std::pair<iterator, iterator> series(size_type s)
  {
    return std::make_pair(iterator(&array_[s], s),
			  iterator(&array_[s + num_series_], s));
  }
  std::pair<const_iterator, const_iterator> series(size_type s) const
  {
    return std::make_pair(const_iterator(&array_[s], s),
			  const_iterator(&array_[s + num_series_], s));
  }

  std::pair<iterator, iterator>
  insert_link(const T& t,
	      const iterator& prev0, const iterator& prev1,
	      const iterator& next0, const iterator& next1)
  {
    // get a new node
    node_type* n = new_node();
    n->data_ = t;
  
    n->series[0] = prev0.ser_;
    n->series[1] = prev1.ser_;
  
    // adjust link pointers
    n->prev[0] = prev0.node_;
    n->prev[1] = prev1.node_;
    prev0.node_->next[prev0.leg_] = n;
    prev1.node_->next[prev1.leg_] = n;
  
    n->next[0] = next0.node_;
    n->next[1] = next1.node_;
    next0.node_->prev[next0.leg_] = n;
    next1.node_->prev[next1.leg_] = n;
  
    ++num_links_;
    return std::make_pair(iterator(n, n->series[0]),
			  iterator(n, n->series[1]));
  }

  std::pair<iterator, iterator>
  insert_link_next(const T& t, const iterator& prev0, const iterator& prev1)
  { return insert_link(t, prev0, prev1, prev0 + 1, prev1 + 1); }
    
  std::pair<iterator, iterator>
  insert_link_prev(const T& t, const iterator& next0, const iterator& next1)
  { return insert_link(t, next0 - 1, next1 - 1, next0, next1); }

  void erase(const iterator& itr)
  {
    if (itr.node_->is_link()) {
      iterator prev0, next0, prev1, next1;
      if (itr.ser_ == 0) {
	prev0 = itr - 1;
	next0 = itr + 1;
	itr.jump();
	prev1 = itr - 1;
	next1 = itr + 1;
      } else {
	prev1 = itr - 1;
	next1 = itr + 1;
	itr.jump();
	prev0 = itr - 1;
	next0 = itr + 1;
      }
      prev0.node_->next[prev0.leg_] = next0.node_;
      prev1.node_->next[prev1.leg_] = next1.node_;
      next0.node_->prev[next0.leg_] = prev0.node_;
      next1.node_->prev[next1.leg_] = prev1.node_;
      --num_links_;
    } else if (itr.node_->is_cut()) {
      iterator prev = itr - 1;
      iterator next = itr + 1;
      prev.node_->next[prev.leg_] = next.node_;
      next.node_->prev[next.leg_] = prev.node_;
      --num_cuts_;
    } else {
      boost::throw_exception(std::logic_error("amida<>::erase() : couldn't erase node"));
    }
    
    delete_node(node);
  }
  
  void save(alps::ODump& od) const
  {
    od << largest_ << num_series_ << num_nodes_ << num_links_ << num_cuts_
       << ((vacant_ == 0) ? 0 : index(_vacant, *this) + 1);
    for (std::size_t i = 0; i < largest_; ++i) array_[i].save(od, *this);
  }
  void load(alps::IDump& id)
  {
    std::size_t vacant;
    id >> largest_ >> num_series_ >> num_nodes_ >> num_links_ >> num_cuts_
       >> vacant;
    array_.resize(largest_);
    vacant_ = static_cast<node_type*>(vacant == 0 ? 0 : &(_array[vacant - 1]));
    for (std::size_t i = 0; i < largest_; ++i) array_[i].load(id, *this);
  }
  
protected:
  node_type* new_node()
  {
    ++num_nodes_;
    if (vacant_ == 0) {
      // stack expansion
      array_.resize(array_.size() + 1);
      node_type* tmp = &(array_[array_.size() - 1]);
      ++largest_;
      return tmp;
    } else {
      // pop from stack
      node_type* tmp = vacant_;
      vacant_ = vacant_.node_->next[0];
      return tmp;
    }
  }

  void delete_node(node_type* n)
  {
    // push to stack of vacant nodes
    n->set_as_vacant(vacant_);
    vacant_ = n;
    --num_nodes_;
  }
  
private:
  std::deque<node_type> array_;
  node_type* vacant_;    // pointer to the top of vacant node stack
  size_type num_series_; // number of series
  size_type num_nodes_;  // number of nodes
  size_type num_links_;  // number of links
  size_type num_cuts_;   // number of cuts
  size_type largest_;    // max number of nodes
};

} // end namespace looper

#endif // LOOPER_AMIDA_H
