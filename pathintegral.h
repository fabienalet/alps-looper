/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: pathintegral.h 439 2003-10-17 06:19:43Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#ifndef LOOPER_PATHINTEGRAL_H
#define LOOPER_PATHINTEGRAL_H

#include "amida.h"
#include "loop.h"
#include "node.h"
#include "permutation.h"
#include "unionfind.h"
#include "virtualgraph.h"
#include "weight.h"

#include <boost/integer_traits.hpp>
#include <boost/throw_exception.hpp>
#include <cmath>
#include <complex>
#include <stdexcept>

namespace looper {

namespace path_integral {

template<class G, class M, class W>
inline double
energy_offset(const virtual_graph<G>& vg, const M& model, const W& /* weight*/)
{
  typedef typename virtual_graph<G>::graph_type graph_type;
  typedef typename boost::graph_traits<graph_type>::edge_iterator
    edge_iterator;
  
  double offset = 0;
  typename alps::property_map<alps::bond_type_t, graph_type, int>::const_type
    bond_type(alps::get_or_default(alps::bond_type_t(), vg.graph, 0));
  edge_iterator ei_end = boost::edges(vg.graph).second;
  for (edge_iterator ei = boost::edges(vg.graph).first; ei != ei_end; ++ei)
    offset += model.bond(bond_type[*ei]).C;
  return offset;
}

template<class G, class M>
inline double energy_offset(const virtual_graph<G>& vg, const M& model)
{
  return energy_offset(vg, model, default_weight());
}

  
template<bool HasCTime = false, class U = uint32_t> class node;

template<class U>
class node<false, U> : public node_type
{
private:
  typedef node_type base_type;
  typedef looper::unionfind::node<looper::loop_segment> segment_type;
  
public:
  typedef double time_type;
  static const bool has_ctime = false;
  
  node() : base_type(), time_(0), bond_(0), segment0_(), segment1_() {}
  
  time_type time() const { return time_; }
  uint32_t bond() const { return bond_; }
  
  void set_bond(uint32_t b) { bond_ = b; }
  void set_time(time_type t) { time_ = t; }
  
//   void set_new(uint32_t b, uint32_t is_refl, uint32_t is_frozen) {
//     base_type::set_new(is_refl, is_frozen);
//     bond_ = b;
//   }
//   void set_new(uint32_t b, uint32_t is_refl, uint32_t is_frozen,
// 	       uint32_t is_anti) {
//     base_type::set_new(is_refl, is_frozen, is_anti);
//     bond_ = b;
//   }
  
  segment_type& loop_segment(int i) {
    return (i == 0 ? segment0_ : segment1_);
  }
  const segment_type& loop_segment(int i) const {
    return (i == 0 ? segment0_ : segment1_);
  }
  int loop_index(int i) const { return loop_segment(i).root()->index; }
  
  void clear() {
    base_type::clear();
    segment0_.reset();
    segment1_.reset();
  }
  
  void output(std::ostream& os) const {
    base_type::output(os);
    os << " time = " << time_ << " bond = " << bond_ ;
  }
  
  void save(alps::ODump& od) const {
    base_type::save(od);
    od << time_ << bond_;
    // segment[01]_ are not saved
  }
  void load(alps::IDump& id) {
    base_type::load(id);
    id >> time_ >> bond_;
    // segment[01]_ are not restored
  }
  
private:
  time_type time_;
  uint32_t bond_;
  segment_type segment0_;
  segment_type segment1_;
};

template<class U>
class node<true, U> : public node<false, U>
{
public:
  static const bool has_ctime = true;
  
  typedef node<false>::time_type time_type;
  typedef std::complex<time_type> ctime_type;
  
  ctime_type ctime() const { return _ctime; }
  void set_time(time_type t) {
    node<false>::set_time(t);
#ifdef M_PI
    _ctime = std::exp(2 * M_PI * t);
#else
    _ctime = std::exp(2 * 3.1415926535897932385 * t);
#endif
  }
  
  void output(std::ostream& os) const {
    node<false>::output(os);
    os << " ctime = " << _ctime;
  }
  
  void save(alps::ODump& od) const {
    node<false>::save(od);
    od << _ctime;
  }
  void load(alps::IDump& id) {
    node<false>::load(id);
    id >> _ctime;
  }
  
private:
  ctime_type _ctime;
};

// initialize
template<class N, class G>
inline void initialize(amida<N>& config, const virtual_graph<G>& vg)
{
  typedef typename boost::graph_traits<
    typename virtual_graph<G>::graph_type>::vertex_iterator vertex_iterator;
  
  config.init(boost::num_vertices(vg.graph));
  
  vertex_iterator vi_end = boost::vertices(vg.graph).second;
  for (vertex_iterator vi = boost::vertices(vg.graph).first; vi != vi_end; ++vi) {
    config.series(*vi).first ->set_time(0.);
    config.series(*vi).second->set_time(1.);
    config.series(*vi).first ->conf() = 0;
    config.series(*vi).second->conf() = 0;
  }
}

template<class N, class G, class M, class RNG, class W>
inline std::pair<int, int>
do_update(amida<N>& config, const virtual_graph<G>& vg, const M& model,
	  double beta, RNG& uniform_01, const W& /* weight */)
{
  typedef typename amida<N>::iterator           iterator;
  typedef typename amida<N>::value_type         node_type;
  typedef typename virtual_graph<G>::graph_type graph_type;
  typedef typename boost::graph_traits<graph_type>::vertex_iterator
    vertex_iterator;
  typedef typename boost::graph_traits<graph_type>::edge_iterator
    edge_iterator;
  typedef W weight_type;
  
  //
  // labeling
  //
  
  edge_iterator ei_end = boost::edges(vg.graph).second;
  for (edge_iterator ei = boost::edges(vg.graph).first; ei != ei_end; ++ei) {
    
    int bond = boost::get(edge_index_t(), vg.graph, *ei); // bond index
    
    // setup iterators
    iterator itr0 = config.series(boost::source(*ei, vg.graph)).first;
    iterator itr1 = config.series(boost::target(*ei, vg.graph)).first;
    int c0 = itr0->conf();    
    int c1 = itr1->conf();
    
    // setup bond weight
    weight_type weight(model.bond(boost::get(edge_type_t(), vg.graph, *ei)));
    std::vector<double> trials;
    fill_duration(uniform_01, trials, beta * weight.density, 1.);
    
    // iteration up to t = 1
    std::vector<double>::const_iterator ti_end = trials.end();
    for (std::vector<double>::const_iterator ti = trials.begin();
	 ti != ti_end; ++ti) {
      while (itr0->time() < *ti) { 
	if (itr0->bond() == bond) // labeling existing link
	  itr0->set_old(uniform_01() < weight.p_reflect);
	if (itr0->is_old()) c0 ^= 1;
	++itr0;
      }
      while (itr1->time() < *ti) {
	if (itr1->is_old()) c1 ^= 1;
	++itr1;
      }
      if (uniform_01() < weight.p_accept(c0, c1)) {
	// insert new link
	iterator itr_new =
	  config.insert_link_prev(node_type(), itr0, itr1).first;
	itr_new->set_time(*ti);
	itr_new->set_bond(boost::get(edge_index_t(), vg.graph, *ei));
	itr_new->set_new(c0 ^ c1, (uniform_01() < weight.p_freeze));
      }
    }
    while (!itr0.at_top()) { 
      if (itr0->bond() == bond)	// labeling existing link
	itr0->set_old(uniform_01() < weight.p_reflect);
      ++itr0;
    }
  }
  std::cout << "labeling done.\n";
  
  //
  // cluster identification using union-find algorithm
  //
  
  vertex_iterator vi_end = boost::vertices(vg.graph).second;
  for (vertex_iterator vi = boost::vertices(vg.graph).first; vi != vi_end; ++vi) {
    
    // setup iterators
    iterator itrD = config.series(*vi).first;
    iterator itrU = itrD + 1;
    
    // iteration up to t = 1
    while (true) {
      if (itrU.at_top()) {
	if (itrD.at_bottom())
	  unionfind::unify(itrU->loop_segment(0),
			   itrD->loop_segment(0));
	else
	  unionfind::unify(itrU->loop_segment(0),
			   itrD->loop_segment(1^(itrD.leg()|itrD->is_refl())));
	break; // finish
      } else {
	if (itrU.leg() == 0 && itrU->is_frozen()) // frozen link
	  unionfind::unify(itrU->loop_segment(0), itrU->loop_segment(0));
	if (itrD.at_bottom())
	  unionfind::unify(itrU->loop_segment(itrU.leg()|itrU->is_refl()),
			   itrD->loop_segment(0));
	else
	  unionfind::unify(itrU->loop_segment(itrU.leg()|itrU->is_refl()),
			   itrD->loop_segment(1^(itrD.leg()|itrD->is_refl())));
	itrD = itrU++; // next
      }
    }
  }
  
  std::vector<int> r, c0, c1;
  for (int i = 0; i < vg.mapping.num_groups(); ++i) {
    int s2 = vg.mapping.num_virtual_vertices(i);
    int offset = *(vg.mapping.virtual_vertices(i).first);
    r.resize(s2);
    c0.resize(s2);
    c1.resize(s2);
    vertex_iterator vi_end = vg.mapping.virtual_vertices(i).second;
    for (vertex_iterator vi = vg.mapping.virtual_vertices(i).first;
	 vi != vi_end; ++vi) {
      r[*vi - offset] = *vi - offset;
      c0[*vi - offset] = config.series(*vi).first->conf();
      c1[*vi - offset] = config.series(*vi).second->conf();
    }
    restricted_random_shuffle(r.begin(), r.end(),
			      c0.begin(), c0.end(),
			      c1.begin(), c1.end(),
			      uniform_01);
    for (vertex_iterator vi = vg.mapping.virtual_vertices(i).first;
	 vi != vi_end; ++vi)
      unionfind::unify(
        config.series(*vi            ).first ->loop_segment(0),
        config.series(r[*vi - offset]).second->loop_segment(0));
  }

  int num_loops0 = 0;
  vi_end = boost::vertices(vg.graph).second;
  for (vertex_iterator vi = boost::vertices(vg.graph).first;
       vi != vi_end; ++vi) {
    iterator itr = config.series(*vi).first;
    if (itr->loop_segment(0).root()->index == loop_segment::undefined)
      itr->loop_segment(0).root()->index = num_loops0++;
  }
  int num_loops = num_loops0;
  vi_end = boost::vertices(vg.graph).second;
  for (vertex_iterator vi = boost::vertices(vg.graph).first;
       vi != vi_end; ++vi) {
    
    // setup iterators
    iterator itr = ++config.series(*vi).first;
    
    // iteration up to t = 1
    while (!itr.at_top()) {
      if (itr.leg() == 0) {
	if (itr->loop_segment(0).is_root() &&
	    itr->loop_segment(0).index == loop_segment::undefined)
	  itr->loop_segment(0).index = num_loops++;
	if (itr->loop_segment(1).is_root() &&
	    itr->loop_segment(1).index == loop_segment::undefined)
	  itr->loop_segment(1).index = num_loops++;
      }
      ++itr;
    }
  }
  std::cout << "identification done.\n";

  return std::make_pair(num_loops0, num_loops); // return number of loops
}

template<class N, class G, class M, class RNG>
inline
std::pair<int, int>
do_update(amida<N>& config, const virtual_graph<G>& vg, const M& model,
	  double beta, RNG& uniform_01)
{
  return do_update(config, vg, model, beta, uniform_01, default_weight());
}

} // namespace path_integral

} // namespace looper

#endif // LOOPER_PATHINTEGRAL_H
