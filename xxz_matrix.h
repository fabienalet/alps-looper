/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: xxz_matrix.h 408 2003-10-10 09:34:54Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#ifndef LOOPER_XXZ_MATRIX_H
#define LOOPER_XXZ_MATRIX_H

#include <alps/model.h>
#include <boost/multi_array.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/io.hpp>

namespace looper {

template <class T = double, class M = boost::numeric::ublas::matrix<T> >
class xxz_matrix
{
public:
  typedef T value_type;
  typedef M matrix_type;
  typedef typename matrix_type::size_type size_type;

  xxz_matrix() : matrix_() {}
  xxz_matrix(const xxz_matrix& m) : matrix_(m.matrix_) {}
  template<class I>
  xxz_matrix(const alps::half_integer<I>& s0, const alps::half_integer<I>& s1,
	     double e0, double jxy, double jz) : matrix_()
  { build(s0, s1, e0, jxy, jz); }
  
  // access to matrix
  matrix_type& matrix() { return matrix_; }
  const matrix_type& matrix() const { return matrix_; }

  // access to to rows
  typename matrix_type::matrix_row_type operator[](size_type i) {
    return matrix_[i];
  }
  typename matrix_type::const_matrix_row_type operator[](size_type i) const {
    return matrix_[i];
  }

  template<class I>
  void build(const alps::half_integer<I>& s0, const alps::half_integer<I>& s1,
	     double e0, double jxy, double jz)
  {
    typedef alps::half_integer<I> half_integer_type;
    
    // set matrix dimension
    int dim = (s0.get_twice()+1) * (s1.get_twice()+1);
    matrix_.resize(dim, dim);
    for (int i = 0; i < dim; ++i)
      for (int j = 0; j < dim; ++j)
	matrix_[i][j] = value_type(0);

    // diagonal elements: jz sz0 sz1
    for (half_integer_type sz0 = s0; sz0 >= -s0; --sz0) {
      for (half_integer_type sz1 = s1; sz1 >= -s1; --sz1) {
	matrix_[index(s0, s1, sz0, sz1)][index(s0, s1, sz0, sz1)] = 
	  e0 - jz * double(sz0) * double(sz1);
      }
    }

    // off-diagonal elements: jxy s0+ s1- / 2
    for (half_integer_type sz0 = s0-1; sz0 >= -s0; --sz0) {
      for (half_integer_type sz1 = s1; sz1 >= -s1+1; --sz1) {
	matrix_[index(s0, s1, sz0+1, sz1-1)][index(s0, s1, sz0, sz1)] =
	  - 0.5 * jxy *
	  std::sqrt(double(s0-sz0) * double(s0+sz0+1)) * 
	  std::sqrt(double(s1+sz1) * double(s1-sz1+1));
      }
    }

    // off-diagonal elements: jxy s0- s1+ / 2
    for (half_integer_type sz0 = s0; sz0 >= -s0+1; --sz0) {
      for (half_integer_type sz1 = s1-1; sz1 >= -s1; --sz1) {
	matrix_[index(s0, s1, sz0-1, sz1+1)][index(s0, s1, sz0, sz1)] =
	  - 0.5 * jxy *
	  std::sqrt(double(s0+sz0) * double(s0-sz0+1)) * 
	  std::sqrt(double(s1-sz1) * double(s1+sz1+1));
      }
    }
  }
  
protected:
  template<class I>
  I index(const alps::half_integer<I>& s0,
	  const alps::half_integer<I>& s1,
	  const alps::half_integer<I>& sz0,
	  const alps::half_integer<I>& sz1) const
  {
    return s0.distance(sz0) * (s1.get_twice()+1) + s1.distance(sz1);
  }

private:
  matrix_type matrix_;
};

template <class T, class M>
inline std::ostream& operator<<(std::ostream& os, const xxz_matrix<T, M>& m)
{
  os << m.matrix();
  return os;
}

//
// fitting a matrix to xxz_matrix
//

template <class I, class M>
inline boost::tuple<bool, typename M::value_type, M::value_type, M::value_type>
fit2xxz(const alps::half_integer<I>& s0, const alps::half_integer<I>& s1, 
	const M& mat, typename M::value_type tol = 1.0e-10)
{
  typedef M matrix_type;
  typedef typename M::value_type value_type;
  
  int dim = (s0.get_twice()+1) * (s1.get_twice()+1);
  xxz_matrix<value_type> m1(s0, s1, 0, 1, 1);
  
  // e0
  value_type e0 = 0;
  for (int i = 0; i < dim; ++i) e0 += mat[i][i];
  e0 /= dim;
  
  // jz
  value_type jz = (mat[0][0] - e0) / m1[0][0];
  
  // jxy
  double jxy = 0;
  for (int i = 0; i < dim; ++i) {
    for (int j = 0; j < dim; ++j) {
      if ((i != j) && (m1[i][j] != 0)) {
	jxy = mat[i][j] / m1[i][j];
	break;
      }
    }
    if (jxy != 0) break;
  }
  
  // check
  bool success = true;
  xxz_matrix<value_type> m(s0, s1, e0, jxy, jz);
  for (int i = 0; i < dim; ++i) {
    for (int j = 0; j < dim; ++j) {
      if (std::abs(mat[i][j] - m[i][j]) > tol) success = false;
    }
  }
  
  return boost::make_tuple(success, e0, jxy, jz);
}

template <class I, class T>
inline boost::tuple<bool, T, T, T>
fit2xxz(const alps::half_integer<I>& s0, const alps::half_integer<I>& s1, 
	const boost::multi_array<T, 4>& mat, T tol = 1.0e-10)
{
  typedef T value_type;

  int d0 = s0.get_twice()+1;
  int d1 = s1.get_twice()+1;
  int dim = d0 * d1;

  boost::numeric::ublas::matrix<value_type> m(dim, dim);
  for (int i0 = 0; i0 < d0; ++i0)
    for (int i1 = 0; i1 < d1; ++i1)
      for (int j0 = 0; j0 < d0; ++j0)
	for (int j1 = 0; j1 < d1; ++j1)
	  m[i0 * d1 + i1][j0 * d1 + j1] = mat[i0][i1][j0][j1];

  return fit2xxz(s0, s1, m, tol);
}

} // end namespace looper

#endif // LOOPER_XXZ_MATRIX_H
