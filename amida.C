/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: amida.C 427 2003-10-16 05:23:18Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#include "amida.h"
#include "vectorhelper.h"

#include <boost/random.hpp>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <string>

const std::string dump_xdr = "amida.xdr";

const std::size_t n_series = 4;
const std::size_t n_nodes = 50;

#ifdef BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
using namespace looper;
#endif

template<class T>
int index(const looper::amida<T>& a,
	  const looper::amida<std::size_t>::iterator& itr)
{
  return looper::index_helper<>::index(a.base(),
    static_cast<looper::amida_node<T> *>(itr.node_));
}

template<class T>
void erase(looper::amida<T>& a, int n)
{
  looper::amida_node<T> * ptr =
    const_cast<looper::amida_node<T> *>(&(a.base()[n]));
  typename looper::amida<T>::iterator itr(ptr, ptr->series[0]);
  a.erase(itr);
}

template<class T>
void output_serial(const looper::amida<T>& a, std::ostream& os = std::cout)
{
  os << "[amida Information]\n";
  for (std::size_t i = 0; i != a.base().size(); ++i) {
    looper::amida_node<T> * p =
      const_cast<looper::amida_node<T> *>(&(a.base()[i]));
    typename looper::amida<T>::iterator s0(p, p->series[0]);
    typename looper::amida<T>::iterator s1(p, p->series[1]);
    if (!p->is_vacant()) {
      if (p->at_boundary()) {
        if (p->at_bottom()) {
          os << index(a, s0) << '\t' << "root at " << s0.ser_;
          os << " :\t" << "next node is "
             << index(a, s0 + 1);
          os << "  ";
	  os << "node: " << index(a, s0) << ", contents: " << p->data_;
          os << std::endl;
        } else {
          os << index(a, s0) << '\t' << "goal at " << s0.ser_;
          os << " :\t" << "prev node is " 
             << index(a, s0 - 1);
          os << "  ";
	  os << "node: " << index(a, s0) << ", contents: " << p->data_;
          os << std::endl;
        }
      } else {
        os << index(a, s0) << '\t' << "node connecting "
           << s0.ser_ << " and " << s1.ser_;
        os << " :\t" << index(a, s0 + 1);
        os << ' ' << index(a, s0 - 1);
        os << ' ' << index(a, s1 + 1);
        os << ' ' << index(a, s1 - 1);
        os << '\t';
	os << "node: " << index(a, s0) << ", contents: " << p->data_;
        os << std::endl;
      }
    }
  }
}

template<class T>
void output_stack(const looper::amida<T>& a, std::ostream& os = std::cout)
{
  os << "[amida Stack Information]\n";
  for (looper::amida_node_base * s =
	 const_cast<looper::amida_node_base *>(a.vacant()); s != 0;
       s = s->next[0]) {
    typename looper::amida<T>::iterator
      itr(static_cast<typename looper::amida<T>::node_type *>(s),
	  s->series[0]);
    os << index(a, itr) << "->";
  }
  os << "NULL\n";
}

template<class T>
std::ostream& operator<<(std::ostream& os, const looper::amida<T>& a)
{ output_serial(a, os); output_stack(a, os); return os; }


int main() {

#ifndef BOOST_NO_EXCEPTIONS
try {
#endif

  typedef boost::mt19937 rng_type;
  typedef boost::uniform_int<> uniform_int;
  rng_type rng;

  std::cout << "[[amida test]]\n";

  // amida array
  looper::amida<std::size_t> amida(n_series);

  // insert nodes randomly
  std::size_t n0, n1;
  for (std::size_t i = 0; i < n_nodes; i++) {
    n0 = uniform_int(0, n_series - 1)(rng);
    n1 = n0;
    while (n0 == n1) n1 = uniform_int(0, n_series - 1)(rng);
    looper::amida<std::size_t>::iterator r0 = amida.series(n0).first;
    looper::amida<std::size_t>::iterator r1 = amida.series(n1).first;
    looper::amida<std::size_t>::iterator r = 
      amida.insert_link_next(0, r0, r1).first;
    std::cout << "node connecting " << n0 << " and " << n1 
	      << " inserted at " << index(amida, r) << std::endl;
  }

  erase(amida, 10);
  erase(amida, 16);
  erase(amida, 17);
  erase(amida, 12);

  std::cout << std::endl;
  std::cout << amida;

  std::cout << "\n[[ trace along series ]]\n";

  for (std::size_t i = 0; i < n_series; i++) {
    std::cout << i << '\t';
    looper::amida<std::size_t>::iterator a = amida.series(i).first;
    while (! a.at_top()) {
      std::cout << "(" << index(amida, a) << ',' << a.leg() << ")->";
      ++a;
    }
    std::cout << "(" << index(amida, a) << ',' << a.leg() << ")\n";
  }

  std::cout << "\n[[ trace along world line ]]\n";
  for (std::size_t i = 0; i < n_series; i++) {
    looper::amida<std::size_t>::iterator a = amida.series(i).first;
    std::cout << "[" << index(amida, a) << "," << a.series() << "]";
    ++a;
    while (! a.at_boundary()) {
      std::cout << "->(" << index(amida, a) << "," << a.series() << ")";
      a.jump();
      std::cout << "->(" << index(amida, a) << "," << a.series() << ")";
      ++a;
    }
    std::cout << "->[" << index(amida, a) << "," << a.series() << "]\n";
  }

  std::cout << "\n[[ trace along loop ]]\n";
  std::size_t d;

  for (std::size_t i = 0; i < n_series; i++) {
    looper::amida<std::size_t>::iterator a = amida.series(i).first;
    d = 0; // upward
    std::cout << "[" << index(amida, a) << "," << a.series() << "]";
    if (d == 0) ++a; else --a; // proceed(a, d);
    while (! a.at_boundary()) {
      d ^= 1;
      std::cout << "->(" << index(amida, a) << "," << a.series() << ")";
      a.jump();
      std::cout << "->(" << index(amida, a) << "," << a.series() << ")";
      if (d == 0) ++a; else --a; // proceed(a, d);
    }
    std::cout << "->[" << index(amida, a) << "," << a.series() << "]\n";
  }

  for (std::size_t i = 0; i < n_series; i++) {
    looper::amida<std::size_t>::iterator a = amida.series(i).second;
    d = 1; // downward
    std::cout << "[" << index(amida, a) << "," << a.series() << "]";
    if (d == 0) ++a; else --a; // proceed(a, d);
    while (! a.at_boundary()) {
      d ^= 1;
      std::cout << "->(" << index(amida, a) << "," << a.series() << ")";
      a.jump();
      std::cout << "->(" << index(amida, a) << "," << a.series() << ")";
      if (d == 0) ++a; else --a; // proceed(a, d);
    }
    std::cout << "->[" << index(amida, a) << "," << a.series() << "]\n";
  }

  std::cout << "[Save & load test]\n";

  {
    alps::OXDRFileDump dump(dump_xdr);
    std::cout << "Saving to " << dump_xdr << "...\n";
    dump << amida;
  }

  amida.clear();

  {
    alps::IXDRFileDump dump(dump_xdr);
    std::cout << "Loading from " << dump_xdr << "...\n";
    dump >> amida;
  }

  for (std::size_t i = 0; i < n_series; i++) {
    looper::amida<std::size_t>::iterator a = amida.series(i).second;
    d = 1; // downward
    std::cout << "[" << index(amida, a) << "," << a.series() << "]";
    if (d == 0) ++a; else --a; // proceed(a, d);
    while (! a.at_boundary()) {
      d ^= 1;
      std::cout << "->(" << index(amida, a) << "," << a.series() << ")";
      a.jump();
      std::cout << "->(" << index(amida, a) << "," << a.series() << ")";
      if (d == 0) ++a; else --a; // proceed(a, d);
    }
    std::cout << "->[" << index(amida, a) << "," << a.series() << "]\n";
  }

#ifndef BOOST_NO_EXCEPTIONS
} 
catch (const std::exception& excp) {
  std::cerr << excp.what() << std::endl;
  std::exit(-1); }
catch (...) {
  std::cerr << "Unknown exception occurred!" << std::endl;
  std::exit(-1); }
#endif

}
