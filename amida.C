/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: amida.C 408 2003-10-10 09:34:54Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#include "amida.h"

#include <boost/random.hpp>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <string>

const std::string dump_xdr = "amida.xdr";

const std::size_t n_series = 4;
const std::size_t n_nodes = 50;

#ifdef BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
using namespace looper;
#endif

int main() {

#ifndef BOOST_NO_EXCEPTIONS
try {
#endif

  typedef boost::mt19937 rng_type;
  typedef boost::uniform_int<> uniform_int;
  rng_type rng;

  std::cout << "[[amida test]]\n";

  // amida array
  looper::amida<std::size_t> amida(n_series);

  // insert nodes randomly
  std::size_t n0, n1;
  for (std::size_t i = 0; i < n_nodes; i++) {
    looper::amida<std::size_t>::pointer a;
    n0 = uniform_int(0, n_series - 1)(rng);
    n1 = n0;
    while (n0 == n1) n1 = uniform_int(0, n_series - 1)(rng);
    looper::amida<std::size_t>::series_iterator r0 = amida.series(n0).first;
    looper::amida<std::size_t>::series_iterator r1 = amida.series(n1).first;
    a = amida.insert_link_next(0, r0, r1);
    std::cout << "node connecting " << n0 << " and " << n1 
	      << " inserted at " << index(a, amida) << std::endl;
  }

  amida.erase(10);
  amida.erase(16);
  amida.erase(17);
  amida.erase(12);

  std::cout << std::endl;
  std::cout << amida;

  std::cout << "\n[[ trace along series ]]\n";

  for (std::size_t i = 0; i < n_series; i++) {
    std::cout << i << '\t';
    looper::amida<std::size_t>::series_iterator a = amida.series(i).first;
    while (! a->at_top()) {
      std::cout << "(" << index(a, amida) << ',' << leg(a) << ")->";
      a++;
    }
    std::cout << "(" << index(a, amida) << ',' << leg(a) << ")\n";
  }

  std::cout << "\n[[ trace along world line ]]\n";
  for (std::size_t i = 0; i < n_series; i++) {
    looper::amida<std::size_t>::series_iterator a = amida.series(i).first;
    std::cout << "[" << index(a, amida) << "," << series(a) << "]";
    a++;
    while (! a->at_boundary()) {
      std::cout << "->(" << index(a, amida) << "," << series(a) << ")";
      jump(a);
      std::cout << "->(" << index(a, amida) << "," << series(a) << ")";
      a++;
    }
    std::cout << "->[" << index(a, amida) << "," << series(a) << "]\n";
  }

  std::cout << "\n[[ trace along loop ]]\n";
  std::size_t d;

  for (std::size_t i = 0; i < n_series; i++) {
    looper::amida<std::size_t>::series_iterator a = amida.series(i).first;
    d = 0; // upward
    std::cout << "[" << index(a, amida) << "," << series(a) << "]";
    proceed(a, d);
    while (! a->at_boundary()) {
      d ^= 1;
      std::cout << "->(" << index(a, amida) << "," << series(a) << ")";
      jump(a);
      std::cout << "->(" << index(a, amida) << "," << series(a) << ")";
      proceed(a, d);
    }
    std::cout << "->[" << index(a, amida) << "," << series(a) << "]\n";
  }

  for (std::size_t i = 0; i < n_series; i++) {
    looper::amida<std::size_t>::series_iterator a = amida.series(i).second;
    d = 1; // downward
    std::cout << "[" << index(a, amida) << "," << series(a) << "]";
    proceed(a, d);
    while (! a->at_boundary()) {
      d ^= 1;
      std::cout << "->(" << index(a, amida) << "," << series(a) << ")";
      jump(a);
      std::cout << "->(" << index(a, amida) << "," << series(a) << ")";
      proceed(a, d);
    }
    std::cout << "->[" << index(a, amida) << "," << series(a) << "]\n";
  }

  std::cout << "[Save & load test]\n";

  {
    alps::OXDRFileDump dump(dump_xdr);
    std::cout << "Saving to " << dump_xdr << "...\n";
    dump << amida;
  }

  amida.clear();

  {
    alps::IXDRFileDump dump(dump_xdr);
    std::cout << "Loading from " << dump_xdr << "...\n";
    dump >> amida;
  }

  for (std::size_t i = 0; i < n_series; i++) {
    looper::amida<std::size_t>::series_iterator a = amida.series(i).second;
    d = 1; // downward
    std::cout << "[" << index(a, amida) << "," << series(a) << "]";
    proceed(a, d);
    while (! a->at_boundary()) {
      d ^= 1;
      std::cout << "->(" << index(a, amida) << "," << series(a) << ")";
      jump(a);
      std::cout << "->(" << index(a, amida) << "," << series(a) << ")";
      proceed(a, d);
    }
    std::cout << "->[" << index(a, amida) << "," << series(a) << "]\n";
  }

#ifndef BOOST_NO_EXCEPTIONS
} 
catch (const std::exception& excp) {
  std::cerr << excp.what() << std::endl;
  std::exit(-1); }
catch (...) {
  std::cerr << "Unknown exception occurred!" << std::endl;
  std::exit(-1); }
#endif

}
