/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: percolation_impl.h 461 2003-10-22 14:34:25Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#ifndef PERCOLATION_IMPL_H
#define PERCOLATION_IMPL_H

#include <looper/copyright.h>
#include <looper/union_find.h>

#include <alps/alea.h>
#include <alps/scheduler.h>
#include <boost/graph/graph_traits.hpp>
#include <utility>

struct percolation
{
  class site
  {
  private:
    struct node_base {
      bool occupied;
      void reset() { occupied = false; }
      node_base& operator+=(const node_base&) { return *this; }
    };
    typedef looper::union_find::node<node_base> node_type;
    typedef std::vector<node_type> vector_type;
    
  public:
    typedef alps::BasicSimpleObservable<double, alps::NoBinning<double> >
      measurement_type;
    
    template<class G>
    site(const G& g, double p) : site_(boost::num_vertices(g)), prob_(p) {}
    
    template<class G>
    site(const G& g, double p, alps::ObservableSet& m) :
      site_(boost::num_vertices(g)), prob_(p)
    {
      // setup measurements
      m << measurement_type("concentration");
      m << measurement_type("number of clusters");
      m.reset(true);
    }
    
    template<class G, class RNG>
    void step(const G& g, RNG& random_01, alps::ObservableSet& m)
    {
      // generate sample
      int n = 0;
      vector_type::iterator itr_end = site_.end();
      for (vector_type::iterator itr = site_.begin(); itr != itr_end; ++itr) {
	itr->reset();
	if (random_01() < prob_) {
	  itr->occupied = true;
	  ++n;
	}
      }
      
      // union_find
      typename boost::graph_traits<G>::edge_iterator ei, ei_end;
      for (boost::tie(ei, ei_end) = boost::edges(g); ei != ei_end; ++ei) {
	vector_type::iterator s_itr = site_.begin() + boost::source(*ei, g);
	vector_type::iterator t_itr = site_.begin() + boost::target(*ei, g);
	if (s_itr->occupied && t_itr->occupied)
	  looper::union_find::unify(*s_itr, *t_itr);
      }
      
      // measurement
      node_type::weight_type max_weight = 0;
      int num_clusters = 0;
      int sc = 0;
      itr_end = site_.end();
      for (vector_type::iterator itr = site_.begin(); itr != itr_end; ++itr) {
	if (itr->occupied && itr->is_root()) {
	  max_weight = std::max(max_weight, itr->weight());
	  ++num_clusters;
	  sc += itr->weight();
	}
      }
      
      m.template get<measurement_type>("concentration") <<
	double(n) / boost::num_vertices(g);
      m.template get<measurement_type>("number of clusters") <<
	double(num_clusters) / boost::num_vertices(g);
    }
    
  private:
    vector_type site_;
    double prob_;
  };
  
  class bond
  {
  private:
    typedef looper::union_find::node<> node_type;
    typedef std::vector<node_type> vector_type;
    
  public:
    typedef alps::BasicSimpleObservable<double, alps::NoBinning<double> >
      measurement_type;
    
    template<class G>
    bond(const G& g, double p) : site_(boost::num_vertices(g)), prob_(p) {}
    
    template<class G>
    bond(const G& g, double p, alps::ObservableSet& m) :
      site_(boost::num_vertices(g)), prob_(p)
    {
      // setup measurements
      m << measurement_type("concentration");
      m << measurement_type("number of clusters");
      m.reset(true);
    }
    
    template<class G, class RNG>
    void step(const G& g, RNG& random_01, alps::ObservableSet& m)
    {
      vector_type::iterator itr_end = site_.end();
      for (vector_type::iterator itr = site_.begin(); itr != itr_end; ++itr)
	itr->reset();
      
      // union_find
      int n = 0;
      typename boost::graph_traits<G>::edge_iterator ei, ei_end;
      for (boost::tie(ei, ei_end) = boost::edges(g); ei != ei_end; ++ei) {
	if (random_01() < prob_) {
	  ++n;
	  vector_type::iterator s_itr = site_.begin() + boost::source(*ei, g);
	  vector_type::iterator t_itr = site_.begin() + boost::target(*ei, g);
	  looper::union_find::unify(*s_itr, *t_itr);
	}
      }
      
      // measurement
      node_type::weight_type max_weight = 0;
      int num_clusters = 0;
      int sc = 0;
      itr_end = site_.end();
      for (vector_type::iterator itr = site_.begin(); itr != itr_end; ++itr) {
	if (itr->is_root()) {
	  max_weight = std::max(max_weight, itr->weight());
	  ++num_clusters;
	  sc += itr->weight();
	}
      }
      
      m.template get<measurement_type>("concentration") <<
	double(n) / boost::num_edges(g);
      m.template get<measurement_type>("number of clusters") <<
	double(num_clusters) / boost::num_vertices(g);
    }
    
  private:
    vector_type site_;
    double prob_;
  };

  class worker : public alps::scheduler::LatticeMCRun<>
  {
  public:
    worker(const alps::ProcessList& w, const alps::Parameters& p,
	   int n) : alps::scheduler::LatticeMCRun<>(w, p, n) {}
    virtual ~worker() {}
    
    virtual void dostep() = 0;
    bool is_thermalized() const { return true; }
    virtual double work_done() const = 0;
    
    virtual void save(alps::ODump&) const = 0;
    virtual void load(alps::IDump&) = 0;
  };
  
  class site_worker : public worker
  {
  public:
    site_worker(const alps::ProcessList& w, const alps::Parameters& p, int n) :
      worker(w, p, n), prob_(double(p["probability"])),
      samples_(int(p["samples"])), samples_done_(0),
      sp_(graph(), prob_, measurements) {}
    ~site_worker() {}
    
    void dostep() {
      ++samples_done_;
      sp_.step(graph(), random_01, measurements);
    }
    double work_done() const { return double(samples_done_) / samples_; }
    
    void save(alps::ODump& od) const {
      od << prob_ << samples_ << samples_done_;
    }
    void load(alps::IDump& id) {
      id >> prob_ >> samples_ >> samples_done_;
      if (where.empty()) measurements.compact();
    }
    
  private:  
    double prob_;
    unsigned int samples_;
    unsigned int samples_done_;
    percolation::site sp_;
  };
  
  class bond_worker : public worker
  {
  public:
    bond_worker(const alps::ProcessList& w, const alps::Parameters& p, int n) :
      worker(w, p, n), prob_(double(p["probability"])),
      samples_(int(p["samples"])), samples_done_(0),
      bp_(graph(), prob_, measurements) {}
    ~bond_worker() {}
    
    void dostep() {
      ++samples_done_;
      bp_.step(graph(), random_01, measurements);
    }
    double work_done() const { return double(samples_done_) / samples_; }
    
    void save(alps::ODump& od) const {
      od << prob_ << samples_ << samples_done_;
    }
    void load(alps::IDump& id) {
      id >> prob_ >> samples_ >> samples_done_;
      if (where.empty()) measurements.compact();
    }
    
  private:  
    double prob_;
    unsigned int samples_;
    unsigned int samples_done_;
    percolation::bond bp_;
  };
  
  class factory : public alps::scheduler::Factory
  {
    alps::scheduler::MCSimulation* make_task(const alps::ProcessList& w,
      const boost::filesystem::path& fn) const {
      return new alps::scheduler::MCSimulation(w, fn);
    }
    alps::scheduler::MCSimulation* make_task(const alps::ProcessList& w,
      const boost::filesystem::path& fn, const alps::Parameters&) const {
      return new alps::scheduler::MCSimulation(w, fn);
    }

    worker* make_worker(const alps::ProcessList& w,
			const alps::Parameters& p, int n) const {
      worker* wk;
      if (p["type"] == "site") {
	wk = new site_worker(w, p, n);
      } else if (p["type"] == "bond") {
	wk = new bond_worker(w, p, n);
      } else {
	boost::throw_exception(std::runtime_error("Invalid value for parameter \"type\"."));
      }
      return wk;
    }

    void print_copyright(std::ostream& os) const {
      looper::print_copyright(os);
    }
  };
};

#endif // PERCOLATION_IMPL_H
