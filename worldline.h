/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: worldline.h 431 2003-10-16 09:24:06Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#ifndef LOOPER_WORLDLINE_H
#define LOOPER_WORLDLINE_H

#include "amida.h"
#include "unionfind.h"
#include "pathintegral.h"
#include "permutation.h"
#include "random.h"

#include <alps/osiris.h>
#include <boost/integer_traits.hpp>

namespace looper {

struct loop_segment
{
  BOOST_STATIC_CONSTANT(int, undefined = -1);

  int index;

  loop_segment() : index(undefined) {}
  void reset() { index = undefined; }
  loop_segment& operator+=(const loop_segment&) { return *this; }
};

//
// Bit positions and bit masks
//

template<class U = uint32_t>
class node_flag
{
public:
  typedef U uint_type;

  BOOST_STATIC_CONSTANT(uint_type, B_ADDD = 0);
  BOOST_STATIC_CONSTANT(uint_type, B_REFL = 1);
  BOOST_STATIC_CONSTANT(uint_type, B_FREZ = 2);
  BOOST_STATIC_CONSTANT(uint_type, B_ANTI = 3); // only for XYZ
  BOOST_STATIC_CONSTANT(uint_type, B_CONF = 4);

  // set for newly-added node
  BOOST_STATIC_CONSTANT(uint_type, M_ADDD = 1 << B_ADDD);

  BOOST_STATIC_CONSTANT(uint_type, M_REFL = 1 << B_REFL); 
  BOOST_STATIC_CONSTANT(uint_type, M_FREZ = 1 << B_FREZ);
  BOOST_STATIC_CONSTANT(uint_type, M_ANTI = 1 << B_ANTI); // only for XYZ
  BOOST_STATIC_CONSTANT(uint_type, M_CONF = 1 << B_CONF);
    
  // bit mask for clear()
  BOOST_STATIC_CONSTANT(uint_type, M_CLEAR = M_ANTI | M_CONF);

private:
  BOOST_STATIC_ASSERT((boost::integer_traits<uint_type>::is_integral));
  BOOST_STATIC_ASSERT((boost::integer_traits<uint_type>::const_min == 0));
};


template<class U = uint32_t>
class node_type : private node_flag<U>
{
public:
  typedef U uint_type;

  node_type() : type_(0) {}

  bool is_refl() const { return type_ & M_REFL; }
  bool is_frozen() const { return type_ & M_FREZ; }
  bool is_new_node() const { return type_ & M_ADDD; }
  bool is_old_node() const { return !is_new_node(); }

  uint_type refl() const { return ( type_ >> B_REFL ) & 1; }
  uint_type frozen() const { return ( type_ >> B_FREZ ) & 1; }
  uint_type new_node() const { return ( type_ >> B_ADDD ) & 1; }
  uint_type old_node() const { return 1 ^ (( type_ >> B_ADDD ) & 1); }

  uint_type phase() const { return ( type_ >> B_ANTI ) & 1; }
  uint_type conf() const { return (type_ >> B_CONF) & 1; }

  void set_type(uint_type t) { type_ = t; }
  void clear() { type_ &= M_CLEAR; }

  void set_conf(uint_type c) {
    type_ = ((0xffffffff ^ M_CONF) & type_) | (c << B_CONF); }
  void flip_conf(uint_type c = 1) { type_ ^= (c << B_CONF); }

  void set_new(uint_type is_refl, uint_type is_frozen, uint_type conf,
	       uint_type phase) {
    type_ = M_ADDD | (is_refl << B_REFL) | (is_frozen << B_FREZ) 
      | (conf << B_CONF) | (phase << B_ANTI);
  }
  void set_old(uint_type is_refl, uint_type is_frozen) {
    type_ |= (is_refl << B_REFL) | (is_frozen << B_FREZ);
  }

  void output(std::ostream& os) const {
    os << "refl = " << refl()
       << " frozen = " << frozen()
       << " new_node = " << new_node()
       << " phase = " << phase()
       << " conf = " << conf();
  }

  void save(alps::ODump& od) const { od << type_; }
  void load(alps::IDump& id) { id >> type_; }

private:
  BOOST_STATIC_ASSERT((boost::integer_traits<uint_type>::is_integral));
  BOOST_STATIC_ASSERT((boost::integer_traits<uint_type>::const_min == 0));

  uint_type type_;
};


template<bool HasCTime = false, class U = uint32_t> class node;

template<class U>
class node<false, U> : public node_type<U>
{
private:
  typedef node_type<U> base_type;
  typedef looper::unionfind::node<looper::loop_segment> segment_type;

public:
  typedef double time_type;
  static const bool has_ctime = false;

  node() : base_type(), time_(0), bond_(0), segment0_(), segment1_() {}

  time_type time() const { return time_; }
  uint32_t bond() const { return bond_; }

  void set_bond(uint32_t b) { bond_ = b; }
  void set_time(time_type t) { time_ = t; }

  void set_new(uint32_t b, uint32_t is_refl, uint32_t is_frozen,
	       uint32_t conf, uint32_t phase) {
    base_type::set_new(is_refl, is_frozen, conf, phase);
    bond_ = b;
  }

  segment_type& loop_segment(int i) {
    return (i == 0 ? segment0_ : segment1_);
  }
  const segment_type& loop_segment(int i) const {
    return (i == 0 ? segment0_ : segment1_);
  }
  int loop_index(int i) const { return loop_segment(i).root()->index; }

  void clear() {
    base_type::clear();
    segment0_.reset();
    segment1_.reset();
  }

  void output(std::ostream& os) const {
    base_type::output(os);
    os << " time = " << time_ << " bond = " << bond_ ;
  }

  void save(alps::ODump& od) const {
    base_type::save(od);
    od << time_ << bond_;
    // segment[01]_ are not saved
  }
  void load(alps::IDump& id) {
    base_type::load(id);
    id >> time_ >> bond_;
    // segment[01]_ are not restored
  }
  
private:
  time_type time_;
  uint32_t bond_;
  segment_type segment0_;
  segment_type segment1_;
};

class node<true> : public node<false>
{
public:
  static const bool has_ctime = true;

  typedef node<false>::time_type time_type;
  typedef std::complex<time_type> ctime_type;

  ctime_type ctime() const { return _ctime; }
  void set_time(time_type t) {
    node<false>::set_time(t);
#ifdef M_PI
    _ctime = std::exp(2 * M_PI * t);
#else
    _ctime = std::exp(2 * 3.1415926535897932385 * t);
#endif
  }

  void output(std::ostream& os) const {
    node<false>::output(os);
    os << " ctime = " << _ctime;
  }

  void save(alps::ODump& od) const {
    node<false>::save(od);
    od << _ctime;
  }
  void load(alps::IDump& id) {
    node<false>::load(id);
    id >> _ctime;
  }
  
private:
  ctime_type _ctime;
};

// //
// // helper functions
// //

// template<class NodePtr>
// inline bool not_passed(const NodePtr& ptr, uint32_t path) {
//   if (ptr->is_vacant()) {
//     return false;
//   }
  
//   if (ptr->at_boundary()) {
//     return path == 0 && ptr->loop(0) == Node<>::loop_not_assigned;
//   } else {
//     return ptr->loop(0) == Node<>::loop_not_assigned;
//   }
// }

// template<class WorldLine, class NodePtr, class Loops>
// void check_erase(WorldLine& wline, NodePtr& ptr, const Loops& loops) {
//   if (ptr->is_node()) {
//     if (ptr->at_boundary()) {
//       ptr->flip_conf(loops[loops[ptr->loop(0)].root()].direc);
//       ptr->clear();
//     } else {
//       if (ptr->old_node()) {
// 	if (loops[loops[ptr->loop(0)].root()].direc ^
// 	    loops[loops[ptr->loop(1)].root()].direc == 1) {
// 	  wline.erase(ptr);
// 	} else {
// 	  ptr->flip_conf(loops[loops[ptr->loop(0)].root()].direc);
// 	  ptr->clear();
// 	}
//       } else {
// 	if (loops[loops[ptr->loop(0)].root()].direc ^
// 	    loops[loops[ptr->loop(1)].root()].direc == 0) {
// 	  wline.erase(ptr);
// 	} else {
// 	  ptr->flip_conf(loops[loops[ptr->loop(0)].root()].direc);
// 	  ptr->clear();
// 	}
//       }
//     }
//   }
// }

//
// class template world_line
// 

template<bool HasCTime = false>
class world_line
{
public:
  typedef node<HasCTime>                     node_type;
  // typedef typename amida<node_type>::pointer         node_pointer;
  typedef typename amida<node_type>::iterator iterator;

  static const bool has_ctime = HasCTime;

  // constructors & destructor
  world_line() : config_() {}
  template<class VG, class VM>
  world_line(const VG& vg, const VM& vm, int c = 0) : config_()
  {
    init(vg, vm, c);
  }

  // initialize
  template<class VG, class VM>
  void init(const VG& vg, const VM&, int c = 0)
  {
    assert(c == 0 || c == 1);
    int n = boost::num_vertices(vg);
    config_.init(n);
    for (std::size_t s = 0; s < n; ++s) {
      config_.series(s).first ->set_time(0.);
      config_.series(s).second->set_time(1.);
      config_.series(s).first ->set_conf(c);
      config_.series(s).second->set_conf(c);
    }
  }
  template<class VG, class VM, class RNG>
  void init(const VG& vg, const VM& vm, RNG& rng, double p = 0.5)
  {
    init(vg, vm);
    for (std::size_t s = 0; s < sites(); ++s) {
      if (rng() < p) {
	config_.series(s).first ->set_conf(0);
	config_.series(s).second->set_conf(0);
      } else {
	config_.series(s).first ->set_conf(1);
	config_.series(s).second->set_conf(1);
      }
    }
  }
  
  // size inquiry
//   std::size_t sites() const { return config_.series(); }
//   std::size_t links() const { return config_.links(); }
//   std::size_t cuts() const { return config_.cuts(); }
//   std::size_t nodes() const { return config_.nodes(); }
//   std::size_t nodes_max() const { return config_.nodes_max(); }
  
//   double memory() const { return config_.memory(); }

  // generate iterators, pointers, etc.
  // iterator bottom(std::size_t r) { return config_.series(r).first; }
  // const iterator bottom(std::size_t r) const {
  //   return config_.series(r).first;
  // }
  // iterator top(std::size_t r) { return config_.series(r).second; }
  // const iterator top(std::size_t r) const {
  //  return config_.series(r).second;
  // }
  // node_pointer node(std::size_t i) { return config_.ptr(i); }
  // const node_pointer node(std::size_t i) const { return config_.ptr(i); }

//   std::pair<iterator, iterator>
//   insert(const iterator& curr0, const iterator& curr1,
// 	 const iterator& next0, const iterator& next1,
// 	 double t)
//   {
//     // insert to list
//     node_type k;
//     k.set_time(t);
//     node_pointer itr_new = config_.insert_link(k, curr0, curr1, next0, next1);
//     return std::make_pair(iterator(itr_new, 0),
// 			  iterator(itr_new, 1));
//   }

//   void erase(iterator itr) { config_.erase(itr); }
  
  void save(alps::ODump& od) const { config_.save(od); }
  void load(alps::IDump& id) { config_.load(id); }

  template<class VG, class VM, class M, class RNG>
  void do_labeling(double betga, const VG& vg, const VM& vm, const M& model,
		   RNG& uniform_01);

private:
  amida<node_type> config_;
};

} // end namespace looper


#ifndef BOOST_NO_OPERATORS_IN_NAMESPACE
namespace looper {
#endif

template<bool HasCTime>
alps::ODump& operator<<(alps::ODump& od, const world_line<HasCTime>& wline) {
  wline.save(od);
  return od;
}

template<bool HasCTime>
alps::IDump& operator>>(alps::IDump& id, world_line<HasCTime>& wline) {
  wline.load(id);
  return id;
}

#ifndef BOOST_NO_OPERATORS_IN_NAMESPACE
} // end namespace looper
#endif

namespace looper {

template<bool HasCTime>
template<class VG, class VM, class M, class RNG>
void world_line<HasCTime>::do_labeling(double beta, const VG& vg, const VM& vm,
				       const M& model, RNG& uniform_01)
{
  typedef VG graph_type;
  typedef VM mapping_type;
  typedef typename boost::graph_traits<graph_type>::vertex_iterator
    vertex_iterator;
  typedef typename boost::graph_traits<graph_type>::edge_iterator
    edge_iterator;

  //
  // labeling
  //

  edge_iterator ei_end = boost::edges(vg).second;
  for (edge_iterator ei = boost::edges(vg).first; ei != ei_end; ++ei) {

    int bond = boost::get(edge_index_t(), vg, *ei); // bond index

    // setup iterators
    iterator itr0 = config_.series(boost::source(*ei, vg)).first;
    iterator itr1 = config_.series(boost::target(*ei, vg)).first;
    int c0 = itr0->conf();    
    int c1 = itr1->conf();

    // setup bond weight
    path_integral::weight w(model.bond(boost::get(edge_type_t(), vg, *ei)));
    std::vector<double> trials;
    fill_duration(uniform_01, trials, beta * w.density(), 1.);

    // iteration up to t = 1
    std::vector<double>::const_iterator ti_end = trials.end();
    for (std::vector<double>::const_iterator ti = trials.begin();
	 ti != ti_end; ++ti) {
      while (itr0->time() < *ti) { 
	if (itr0->bond() == bond) {
	  // labeling existing link
	  itr0->set_old((uniform_01() < w.reflect() ? 1 : 0), 0);
	}
	if (itr0->is_old_node()) c0 ^= 1;
	++itr0;
      }
      while (itr1->time() < *ti) { if (itr1->is_old_node()) c1 ^= 1; ++itr1; }
      if (uniform_01() < w.accept(c0, c1)) {
	// insert new link
	iterator itr_new =
	  config_.insert_link_prev(node_type(), itr0, itr1).first;
	bool fz = (uniform_01() < w.freeze());
	itr_new->set_time(*ti);
	itr_new->set_new(boost::get(edge_index_t(), vg, *ei), c0 ^ c1,
			 (fz ? 1 : 0), 0, 0);
	if (fz) unionfind::unify(itr_new->loop_segment(0),
				 itr_new->loop_segment(0));
      }
    }
    while (!itr0.at_top()) { 
      if (itr0->bond() == bond) {
	// labeling existing link
	itr0->set_old((uniform_01() < w.reflect() ? 1 : 0), 0);
      }
      ++itr0;
    }
  }
  std::cout << "labeling done.\n";

  //
  // cluster identification using union-find algorithm
  //

  vertex_iterator vi_end = boost::vertices(vg).second;
  for (vertex_iterator vi = boost::vertices(vg).first; vi != vi_end; ++vi) {

    // setup iterators
    iterator itrD = config_.series(*vi).first;
    iterator itrU = itrD + 1;

    // iteration up to t = 1
    while (!itrU.at_top()) {
      // connect loop segments // FIXME
      itrD = itrU++;
    }
  }

  std::vector<int> r;
  std::vector<int> c0;
  std::vector<int> c1;
  for (int i = 0; i < vm.num_groups(); ++i) {
    int s2 = vm.num_virtual_vertices(i);
    int offset = *(vm.virtual_vertices(i).first);
    r.resize(s2);
    c0.resize(s2);
    c1.resize(s2);
    vertex_iterator vi_end = vm.virtual_vertices(i).second;
    for (vertex_iterator vi = vm.virtual_vertices(i).first;
	 vi != vi_end; ++vi) {
      r[*vi - offset] = *vi - offset;
      c0[*vi - offset] = config_.series(*vi).first->conf();
      c1[*vi - offset] = config_.series(*vi).second->conf();
    }
    restricted_random_shuffle(r.begin(), r.end(),
			      c0.begin(), c0.end(),
			      c1.begin(), c1.end(),
			      uniform_01);
    for (vertex_iterator vi = vm.virtual_vertices(i).first;
	 vi != vi_end; ++vi)
      unionfind::unify(
        config_.series(*vi            ).first ->loop_segment(0),
	config_.series(r[*vi - offset]).second->loop_segment(0));
  }
  std::cout << "identification done.\n";
}

} // namespace looper

#endif // LOOPER_WORLDLINE_H
