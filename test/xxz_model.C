/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: xxz_model.C 454 2003-10-22 00:41:25Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#include <looper/xxz.h>

#include <iostream>

template<class G>
void output(const G& graph, const looper::xxz_model& m)
{
  typedef G graph_type;
  typedef typename boost::graph_traits<graph_type>::vertex_iterator
    vertex_iterator;
  typedef typename boost::graph_traits<graph_type>::edge_iterator
    edge_iterator;

  // site parameters
  std::cout << "number of spin types = " << m.num_spin_types() << std::endl;
  if (m.is_uniform_spin()) {
    std::cout << "S = " << m.uniform_spin() << std::endl;
  }
  typename alps::property_map<alps::site_type_t, graph_type, int>::const_type
    site_type(alps::get_or_default(alps::site_type_t(), graph, 0));
  vertex_iterator vi_end = boost::vertices(graph).second;
  for (vertex_iterator vi = boost::vertices(graph).first; vi != vi_end;
       ++vi) {
    int t = site_type[*vi];
    std::cout << "site " << *vi << ": type = " << t << ", S = " << m.spin(t)
	      << std::endl;
  }
  
  // bond parameters
  std::cout << "number of bond types = " << m.num_bond_types() << std::endl;
  if (m.is_uniform_bond()) {
    std::cout << "C = " << m.uniform_bond().C
	      << ", Jxy = " << m.uniform_bond().Jxy
	      << ", Jz = " << m.uniform_bond().Jz
	      << std::endl;
  }
  typename alps::property_map<alps::bond_type_t, graph_type, int>::const_type
    bond_type(alps::get_or_default(alps::bond_type_t(), graph, 0));
  edge_iterator ei_end = boost::edges(graph).second;
  for (edge_iterator ei = boost::edges(graph).first; ei != ei_end; ++ei) {
    int t = bond_type[*ei];
    std::cout << "bond " << *ei << ": type = " << t
	      << ", C = " << m.bond(t).C
	      << ", Jxy = " << m.bond(t).Jxy
	      << ", Jz = " << m.bond(t).Jz
	      << std::endl;
  }
}

int main()
{
#ifndef BOOST_NO_EXCEPTIONS
try {
#endif

  alps::Parameters params;
  std::cin >> params;

  // get graph
  typedef alps::graph_factory<>::graph_type graph_type;
  alps::graph_factory<graph_type> gf(params);
  const graph_type& graph = gf.graph();

  // get model
  alps::ModelLibrary models(params);

  // construct from model library
  looper::xxz_model m0(params, graph, models);
  output(graph, m0);

  // construct from parameters
  looper::xxz_model m1(-2, -1, alps::half_integer<short>(1.5), graph);
  output(graph, m1);

#ifndef BOOST_NO_EXCEPTIONS
}
catch (std::exception& exc) {
  std::cerr << exc.what() << "\n";
  return -1;
}
catch (...) {
  std::cerr << "Fatal Error: Unknown Exception!\n";
  return -2;
}
#endif
}
