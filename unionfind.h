/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: unionfind.h 404 2003-10-10 05:37:21Z wistaria $
*
* Copyright (C) 2001-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

// Weighted Union-Find Algorithm
// Reference:
//   D. Knuth, `The Art of Computer Programming, Vol. 1, Fundamental
//   Algorithms', 3rd edition (Addison Wesley, Reading, 1997) Sec 2.3.

#ifndef LOOPER_UNIONFIND_H
#define LOOPER_UNIONFIND_H

#include <boost/throw_exception.hpp>
#include <iterator>
#include <stdexcept>
#include <vector>

namespace looper {

namespace unionfind {

namespace detail {

struct null_node {
  void reset() {}
  null_node& operator+=(const null_node&) { return *this; }
};

} // end namespace detail

//
// class template node<>
//
// Argument of unify() function should be type of node<>.
//
// In the base class of node<>, `reset()' and `operator+=()' member
// functions, as well as default and copy constructors, should be
// defined, so that quantities of child cluster can be summed into
// properly.

template<class BASE = detail::null_node, class W = unsigned int>
class node : public BASE
{
public:
  typedef  BASE base_type;
  typedef W    weight_type;

  node() : base_type(), parent_(0), weight_(1) {}
  node(const node& n) : base_type(n), parent_(n.is_root() ? 0 : n.parent_),
			weight_(n.weight_) {}
 
  bool is_root() const { return parent_ == 0; }
  node* root() {
    if (is_root()) {
      return this;
    } else {
      parent_ = parent_->root();
      return parent_;
    }
  }
  const node* root() const {
    if (is_root()) {
      return this;
    } else {
      parent_ = parent_->root();
      return parent_;
    }
  }

  void set_parent(node* p) { parent_ = p; }
  node* parent() { return parent_; }
  const node* parent() const { return parent_; }
 
  weight_type weight() const {
#ifndef NDEBUG
    if (!is_root())
      boost::throw_exception(std::logic_error("unionfind::node::weight() : not a root node"));
#endif
    return weight_;
  }
  
  node& operator+=(node& c) {
    base_type::operator+=(c);
    weight_ += c.weight();
    c.set_parent(this);
    return *this;
  }
  
  void reset() {
    base_type::reset();
    parent_ = 0;
    weight_ = weight_type(1);
  }
  
private:
  // root node     : 0
  // non-root node : points my parent node
  mutable node* parent_;
 
  // root node     : weight of cluster (number of nodes in the cluster)
  // non-root node : meaningless
  weight_type weight_;
};


//
// function unify()
//

template<class T>
inline bool unify(node<T>& node0, node<T>& node1)
{
  // NOTE: if both nodes belong to the same root, then return false

  typedef node<T> node_type;
  node_type* root0 = node0.root();
  node_type* root1 = node1.root();
  if (root0 == root1) {
    // both node belong to the same tree
    return false;
  } else {
    // both node belong to different trees
    if (root0->weight() >= root1->weight()) {
      *root0 += *root1;
    } else {
      *root1 += *root0;
    }
    return true;
  }
}

} // end namespace unionfind

} // end namespace looper

#############################################################################

#if false

namespace detail {

template<class T>
struct UnionFindNode
{
  typedef T value_type;

  static const int32_t no_parent = -1;

  UnionFindNode(const T& t = T()) : value(t), parent(no_parent), weight(1) {}
  void reset() { t.reset(); parent = no_parent; weight = 1; }

  T value;
  mutable int32_t parent;
  mutable uint32_t weight;
};

template<class T, class Ref, class Ptr, class BaseIter>
class UnionFindIterator
{
private:
  typedef UnionFindNode<T> node_type;
  typedef UnionFindNode<T>* node_pointer;
  typedef UnionFindNode<const T>* const_node_pointer;

public:
  // types:
  typedef std::ptrdiff_t                           difference_type;
  typedef T                                        value_type;
  typedef Ref                                      reference;
  typedef Ptr                                      pointer;
  typedef UnionFindIterator<T, T&, T*, BaseIter>             iterator;
  typedef UnionFindIterator<T, const T&, const T*, const BaseIter> const_iterator;
  typedef std::random_access_iterator_tag          iterator_category;

  // construct/copy/destroy:
  UnionFindIterator(BaseIter n) : current_(n) {}

  reference operator*() const { return current_->value; }
  pointer operator->() const { return &(current_->value); }
  reference operator[](difference_type n) const {
    return (current_ + n)->value;
  }

  // difference:
  difference_type operator-(const UnionFindIterator& x) const {
    return current_ - x.current_;
  }

  UnionFindIterator& operator++() { ++current_; return *this; }
  UnionFindIterator operator++(int) {
    UnionFindIterator tmp = *this;
    ++*this;
    return tmp;
  }
  UnionFindIterator& operator--() { --current_; return *this; }
  UnionFindIterator operator--(int) {
    UnionFindIterator tmp = *this;
    --*this;
    return tmp;
  }
  UnionFindIterator& operator+=(difference_type n) {
    current_ += n;
    return *this;
  }
  UnionFindIterator operator+(difference_type n) const {
    UnionFindIterator tmp = *this;
    tmp += n;
    return tmp;
  }
  UnionFindIterator& operator-=(difference_type n) { return *this += (-n); }
  UnionFindIterator operator-(difference_type n) const { return *this + (-n); }

  // comparison:
  bool operator==(const UnionFindIterator& x) const {
    return current_ == x.current_;
  }
  bool operator!=(const UnionFindIterator& x) const { return !(*this == x); }
  bool operator< (const UnionFindIterator& x) const {
    return current_ < x.current_();
  }
  bool operator> (const UnionFindIterator& x) const { return x < *this; }
  bool operator<=(const UnionFindIterator& x) const { return !(x < *this); }
  bool operator>=(const UnionFindIterator& x) const { return !(*this < x); }

private:
  BaseIter current_;
};

} // end namespace detail

class NullUnionFindNode {};

template<class T = NullUnionFindNode>
class UnionFindVector : public std::vector<detail::UnionFindNode<T> >
{
private:
  typedef std::vector<detail::UnionFindNode<T> > BASE_;
  typedef detail::UnionFindNode<T> node_type;

public:
  typedef T value_type;
  typedef T& reference;
  typedef const T& const_reference;
  typedef detail::UnionFindIterator<T, T&, T*, typename BASE_::iterator> iterator;
  typedef detail::UnionFindIterator<T, const T&, const T*, typename BASE_::const_iterator> const_iterator;

  UnionFindVector() : BASE_(0) {}
  explicit UnionFindVector(uint32_t n, const T& v = T())
    : BASE_(n, node_type(v)) {}

  void reset() {
    for (iterator itr = begin(); itr != end(); ++itr) itr->reset();
  }

  void push_back(const T& t = T()) { BASE_::push_back(t); }

  iterator begin() { return iterator(BASE_::begin()); }
  const_iterator begin() const { return const_iterator(BASE_::begin()); }
  iterator end() { return iterator(BASE_::end()); }
  const_iterator end() const { return const_iterator(BASE_::end()); }

  reference operator[](uint32_t n) { return BASE_::operator[](n).value; }
  const_reference operator[](uint32_t n) const {
    return BASE_::operator[](n).value;
  }

  friend bool is_root(const UnionFindVector& v, uint32_t n) {
    return v.is_root(n);
  }
  friend uint32_t parent_index(const UnionFindVector& v, uint32_t n) {
    return v.parent(n);
  }
  // friend uint32_t parent(const UnionFindVector& v, uint32_t n) {
  //   return v.parent(n);
  // }
  friend uint32_t root_index(const UnionFindVector& v, uint32_t n) {
    return v.find_root(n);
  }
  // friend uint32_t root(const UnionFindVector& v, uint32_t n) {
  //   return v.find_root(n);
  // }
  friend uint32_t weight(const UnionFindVector& v, uint32_t n) {
    return v.weight(n);
  }
  friend bool unify(UnionFindVector& v, uint32_t i0, uint32_t i1) {
    return v.unify(i0, i1);
  }
  friend void set_as_root(UnionFindVector& v, uint32_t i) {
    v.set_as_root(i);
  }

  reference root(uint32_t n) { return BASE_::operator[](find_root(n)).value; }
  const_reference root(uint32_t n) const {
    return BASE_::operator[](find_root(n)).value;
  }

protected:
  bool is_root(uint32_t n) const {
    return BASE_::operator[](n).parent == node_type::no_parent;
  }
  uint32_t find_root(uint32_t n) const {
    if (is_root(n)) {
      return n;
    } else {
      uint32_t r = find_root(BASE_::operator[](n).parent);
      BASE_::operator[](n).parent = r;
      return r;
    }
  }
  uint32_t parent(uint32_t n) const {
    return BASE_::operator[](n).parent;
  }
  uint32_t weight(uint32_t n) const {
    return BASE_::operator[](find_root(n)).weight;
  }
  bool unify(uint32_t n0, uint32_t n1) {
    uint32_t r0 = find_root(n0);
    uint32_t r1 = find_root(n1);
    if (r0 != r1) {
      if (BASE_::operator[](r0).weight >= BASE_::operator[](r1).weight) {
	BASE_::operator[](r0).weight += BASE_::operator[](r1).weight;
	BASE_::operator[](r0).value.update(BASE_::operator[](r1).value);
	BASE_::operator[](r1).parent = r0;
      } else {
	BASE_::operator[](r1).weight += BASE_::operator[](r0).weight;
	BASE_::operator[](r1).value.update(BASE_::operator[](r0).value);
	BASE_::operator[](r0).parent = r1;
      }
      return true;
    } else {
      return false;
    }
  }
  void set_as_root(uint32_t n) {
    if (!is_root(n)) {
      uint32_t r = find_root(n);
      BASE_::operator[](n).parent = node_type::no_parent;
      BASE_::operator[](n).weight = BASE_::operator[](r).weight;
      BASE_::operator[](n).value.change(BASE_::operator[](r).value);
      BASE_::operator[](r).parent = n;
    }
  }
};

template<class T>
inline uint32_t index(UnionFindVector<T>& v,
  const typename UnionFindVector<T>::iterator& itr) {
  return itr - v.begin();
}
template<class T>
inline uint32_t index(const UnionFindVector<T>& v,
  const typename UnionFindVector<T>::const_iterator& itr) {
  return itr - v.begin();
}
template<class T>
inline bool is_root(UnionFindVector<T>& v,
  const typename UnionFindVector<T>::iterator& itr) {
  return is_root(v, index(v, itr));
}
template<class T>
inline bool is_root(const UnionFindVector<T>& v,
  const typename UnionFindVector<T>::const_iterator& itr) {
  return is_root(v, index(v, itr));
}
template<class T>
inline uint32_t root_index(UnionFindVector<T>& v,
  const typename UnionFindVector<T>::iterator& itr) {
  return root_index(v, index(v, itr));
}
template<class T>
inline uint32_t root_index(const UnionFindVector<T>& v,
  const typename UnionFindVector<T>::const_iterator& itr) {
  return root_index(v, index(v, itr));
}
template<class T>
inline uint32_t weight(UnionFindVector<T>& v,
  const typename UnionFindVector<T>::iterator& itr) {
  return weight(v, index(v, itr));
}
template<class T>
inline uint32_t weight(const UnionFindVector<T>& v,
  const typename UnionFindVector<T>::const_iterator& itr) {
  return weight(v, index(v, itr));
}
template<class T>
inline uint32_t parent_index(UnionFindVector<T>& v,
  const typename UnionFindVector<T>::iterator& itr) {
  return parent_index(v, index(v, itr));
}
template<class T>
inline uint32_t parent_index(const UnionFindVector<T>& v,
  const typename UnionFindVector<T>::const_iterator& itr) {
  return parent_index(v, index(v, itr));
}

#endif

#endif // LOOPER_UNIONFIND_H
