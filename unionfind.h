/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: unionfind.h 399 2003-10-09 10:54:38Z wistaria $
*
* Copyright (C) 2001-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

// Weighted Union-Find Algorithm
// Reference:
//   D. Knuth, `The Art of Computer Programming, Vol. 1, Fundamental
//   Algorithms', 3rd edition (Addison Wesley, Reading, 1997) Sec 2.3.

#ifndef LOOPER_UNIONFIND_H
#define LOOPER_UNIONFIND_H

#include <iterator>
#include <vector>

// pointer version

namespace looper {

namespace unionfind {

namespace detail {

struct null_node {
  void reset() {}
  null_node& operator+=(const null_node&) { return *this; }
};

} // end namespace detail

//
// class template node<>
//
// Argument of unify() function should be type of node<>.
//
// In the base class of node<>, `reset()' and `operator+=()' member
// functions, as well as default and copy constructors, should be
// defined, so that quantities of child cluster can be summed into
// properly.

template<class BASE = detail::null_node, class W = unsigned int>
class node : public BASE
{
public:
  typedef  BASE base_type;
  typedef W    weight_type;

  node() : base_type(), _parent(0), _weight(1) {}
  node(const node& n) : base_type(n), _parent(n.is_root() ? 0 : n._parent),
			_weight(n._weight) {}
 
  bool is_root() const { return _parent == 0; }
  node* root() {
    if (is_root()) {
      return this;
    } else {
      _parent = _parent->root();
      return _parent;
    }
  }
  const node* root() const {
    if (is_root()) {
      return this;
    } else {
      _parent = _parent->root();
      return _parent;
    }
  }

  void set_parent(node* p) { _parent = p; }
  node* parent() { return _parent; }
  const node* parent() const { return _parent; }
 
  weight_type weight() const {
#ifndef NDEBUG
    if (!is_root())
      boost::throw_exception(std::logic_error("unionfind::node::weight() : not a root node"));
#endif
    return _weight;
  }
  
  node& operator+=(const node& c) {
    base_type::operator+=(c);
    _weight += c->weight();
    c.set_parent(this);
  }
  
  void reset() {
    base_type::reset();
    _parent = 0;
    _weight = weight_type(1);
  }
  
private:
  // root node     : 0
  // non-root node : points my parent node
  mutable node* _parent;
 
  // root node     : weight of cluster (number of nodes in the cluster)
  // non-root node : meaningless
  weight_type _weight;
};


//
// function unify()
//

template<class T>
inline bool unify(node<T>& node0, node<T>& node1)
{
  // NOTE: if both nodes belong to the same root, then return false

  typedef node<T> node_type;
  node_type* root0 = node0.root();
  node_type* root1 = node1.root();
  if (root0 == root1) {
    // both node belong to the same tree
    return false;
  } else {
    // both node belong to different trees
    if (root0->weight() >= root1->weight()) {
      root0 += root1;
    } else {
      root1 += root0;
    }
    return true;
  }
}

} // end namespace unionfind

} // end namespace looper

#endif // LOOPER_UNIONFIND_H
