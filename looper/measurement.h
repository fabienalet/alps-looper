/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: measurement.h 537 2003-11-06 14:47:54Z wistaria $
*
* Copyright (C) 1997-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#ifndef LOOPER_MEASUREMENT_H
#define LOOPER_MEASUREMENT_H

namespace looper {

template<class T> T sqr(T t) { return t * t; }

//
// unimproved estimators
//

// energy offset

template<class P>
inline double energy_offset(const P& param)
{
  return P::qmc_type::energy_offset(param.virtual_graph, param.model);
}

template<class C, class P>
inline double energy_z(const C& config, const P& param)
{
  typedef typename C::qmc_type qmc_type;

  double ene = 0.;
  typename qmc_type::edge_iterator ei, ei_end;
  for (boost::tie(ei, ei_end) = boost::edges(param.virtual_graph.graph);
       ei != ei_end; ++ei)
    ene -= param.model.bond(bond_type(*ei, param.virtual_graph.graph)).jz() *
      qmc_type::static_sz(boost::source(*ei, param.virtual_graph.graph),
			  config) *
      qmc_type::static_sz(boost::target(*ei, param.virtual_graph.graph),
			  config);
  return ene / param.virtual_graph.num_real_vertices;
}


// energy

template<class C, class P>
inline double energy_xy(const C& config, const P& param)
{
  typedef typename C::qmc_type qmc_type;
  return - (double)qmc_type::num_offdiagonals(config) / param.beta /
    param.virtual_graph.num_real_vertices;
}

template<class C, class P>
inline boost::tuple<double, double, double>
energy(const C& config, const P& param)
{
  typedef typename C::qmc_type qmc_type;
  double ez = energy_z(config, param);
  double exy = energy_xy(config, param);
  double e2 = sqr(ez + exy) -
    (double)qmc_type::num_offdiagonals(config) /
    sqr(param.beta * param.virtual_graph.num_real_vertices);
  return boost::make_tuple(ez, exy, e2);
}


// total Sz

template<class C, class P>
inline double uniform_sz(const C& config, const P& param)
{
  typedef typename C::qmc_type qmc_type;
  
  double sz = 0.;
  typename qmc_type::vertex_iterator vi, vi_end;
  for (boost::tie(vi, vi_end) = boost::vertices(param.virtual_graph.graph);
       vi != vi_end; ++vi) {
    sz += qmc_type::static_sz(*vi, config);
  }
  return sz / param.virtual_graph.num_real_vertices;
}


// total stsaggered Sz

template<class C, class P>
inline double staggered_sz(const C& config, const P& param)
{
  typedef typename C::qmc_type qmc_type;
  if (!param.is_bipartite)
    boost::throw_exception(std::runtime_error("lattice is not bipartitle"));
  double ss = 0.;
  typename qmc_type::vertex_iterator vi, vi_end;
  for (boost::tie(vi, vi_end) = boost::vertices(param.virtual_graph.graph);
       vi != vi_end; ++vi)
    ss += gauge(*vi, param.virtual_graph.graph) *
      qmc_type::static_sz(*vi, config);
  return ss / param.virtual_graph.num_real_vertices;
}


// staggered susceptilibity

namespace {

template<class Q> struct staggered_susceptibility_helper;

template<class G, class M, class W, class N>
struct staggered_susceptibility_helper<path_integral<G, M, W, N> >
{
  typedef path_integral<G, M, W, N> qmc_type;
  static double calc(const qmc_type::config_type& config,
		     const qmc_type::parameter_type& param)
  {
    double ss = 0.;
    typename qmc_type::vertex_iterator vi, vi_end;
    for (boost::tie(vi, vi_end) = boost::vertices(param.virtual_graph.graph);
	 vi != vi_end; ++vi)
      ss += gauge(*vi, param.virtual_graph.graph) *
	qmc_type::dynamic_sz(*vi, config, param.virtual_graph);
    return param.beta * ss * ss / param.virtual_graph.num_real_vertices;
  }
};

template<class G, class M, class W, class N>
struct staggered_susceptibility_helper<sse<G, M, W, N> >
{
  typedef sse<G, M, W, N> qmc_type;
  static double calc(const qmc_type::config_type& config,
		     const qmc_type::parameter_type& param)
  {
    double sd = 0.;
    double ss = 0.;
    typename qmc_type::vertex_iterator vi, vi_end;
    for (boost::tie(vi, vi_end) = boost::vertices(param.virtual_graph.graph);
	 vi != vi_end; ++vi) {
      sd += gauge(*vi, param.virtual_graph.graph) *
	qmc_type::dynamic_sz(*vi, config, param.virtual_graph);
      ss += gauge(*vi, param.virtual_graph.graph) *
	qmc_type::static_sz(*vi, config, param.virtual_graph);
    }
    return param.beta * (sqr(sd) + sqr(ss) / (config.os.size() + 1)) /
      param.virtual_graph.num_real_vertices;
  }
};

} // end namespace

template<class C, class P>
inline double staggered_susceptibility(const C& config, const P& param)
{
  if (!param.is_bipartite)
    boost::throw_exception(std::runtime_error("lattice is not bipartitle"));
  return staggered_susceptibility_helper<typename C::qmc_type>::
    calc(config, param);
}


//
// improved estimators
//

template<class C, class P>
inline double energy_z_imp(const C& config, const P& param)
{
  typedef typename C::qmc_type qmc_type;

  double ene = 0.;
  typename qmc_type::edge_iterator ei, ei_end;
  for (boost::tie(ei, ei_end) = boost::edges(param.virtual_graph.graph);
       ei != ei_end; ++ei) {
    typename qmc_type::vertex_descriptor v0 =
      boost::source(*ei, param.virtual_graph.graph);
    typename qmc_type::vertex_descriptor v1 =
      boost::target(*ei, param.virtual_graph.graph);
    if (loop_index_0(v0, config) == loop_index_0(v1, config))
      ene -= model.bond(bond_type(*ei, param.virtual_graph.graph)).jz() *
	static_sz(v0, config) * static_sz(v1, config);
    }
  return ene / param.virtual_graph.num_real_vertices;
}

} // namespace looper

#endif // LOOPER_MEASUREMENT_H
