/**************************************************************************** 
*
* alps/looper: multi-cluster quantum Monte Carlo algorithm for spin systems
*              in path-integral and SSE representations
*
* $Id: xxz_model.C 398 2003-10-09 10:33:05Z wistaria $
*
* Copyright (C) 2001-2003 by Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.
*
* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#include "xxz.h"
#include <iostream>

int main()
{
#ifndef BOOST_NO_EXCEPTIONS
try {
#endif

  alps::Parameters params;
  std::cin >> params;

  // get graph
  typedef alps::graph_factory<>::graph_type graph_type;
  typedef boost::graph_traits<graph_type>::vertex_iterator vertex_iterator;
  typedef boost::graph_traits<graph_type>::edge_iterator edge_iterator;
  alps::graph_factory<graph_type> gf(params);
  const graph_type& graph = gf.graph();

  alps::ModelLibrary models(params);
  
  looper::xxz_model m(params, graph, models);

  // site parameters
  std::cout << "number of spin types = " << m.num_spin_types() << std::endl;
  if (m.is_uniform_spin()) {
    std::cout << "S = " << m.uniform_spin() << std::endl;
  }
  alps::property_map<alps::site_type_t, graph_type, int>::const_type
    site_type(alps::get_or_default(alps::site_type_t(), graph, 0));
  vertex_iterator vi_end = boost::vertices(graph).second;
  for (vertex_iterator vi = boost::vertices(graph).first; vi != vi_end;
       ++vi) {
    int t = site_type[*vi];
    std::cout << "site " << *vi << ": type = " << t << ", S = " << m.spin(t)
	      << std::endl;
  }
  
  // bond parameters
  std::cout << "number of bond types = " << m.num_bond_types() << std::endl;
  if (m.is_uniform_bond()) {
    std::cout << "C = " << m.uniform_bond().C
 	      << ", Jxy = " << m.uniform_bond().Jxy
 	      << ", Jz = " << m.uniform_bond().Jz
 	      << std::endl;
  }
  alps::property_map<alps::bond_type_t, graph_type, int>::const_type
    bond_type(alps::get_or_default(alps::bond_type_t(), graph, 0));
  edge_iterator ei_end = boost::edges(graph).second;
  for (edge_iterator ei = boost::edges(graph).first; ei != ei_end; ++ei) {
    int t = bond_type[*ei];
      std::cout << "bond " << *ei << ": type = " << t
		<< ", C = " << m.bond(t).C
		<< ", Jxy = " << m.bond(t).Jxy
		<< ", Jz = " << m.bond(t).Jz
		<< std::endl;
  }

#ifndef BOOST_NO_EXCEPTIONS
}
catch (std::exception& exc) {
  std::cerr << exc.what() << "\n";
  return -1;
}
catch (...) {
  std::cerr << "Fatal Error: Unknown Exception!\n";
  return -2;
}
#endif
}
